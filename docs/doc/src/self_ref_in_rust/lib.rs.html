<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../self_ref_in_rust/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../self_ref_in_rust/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../self_ref_in_rust/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
</pre><pre class="rust"><code><span class="doccomment">//! 最近一位朋友遇到了这样一个问题：设计类型时，将具有引用关系的两个类型“打包”到同一个结构体中，产生了难以解决的编译错误。</span>
<span class="doccomment">//! 社区中也常常有同学问遇到类似的问题，在这篇文章中我们将从零开始，探究该如何设计这类自引用的类型，并逐步改进我们的设计。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 想象这样一个场景：在设计一个运行时调用动态链接库中的API的接口时，需要先加载动态链接库获得一个`Library`结构，</span>
<span class="doccomment">//! 再从`Library`中获取多个`Function`s（`Function`内部包含`Library`的引用），最后将`Library`与`Function`s放置到</span>
<span class="doccomment">//! 结构体`BundleService`中，于`BundleService`中将`Function`s封装为暴露给用户的方法。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 需求描述非常直观，简直就是把类型定义用文字写了出来，于是我们很快写出了这样一段定义：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! pub struct BundleService&lt;&#39;a&gt; {  </span>
<span class="doccomment">//!     library: Library, </span>
<span class="doccomment">//!     func_login: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 其中`library`是我们加载的动态链接库，`func_*`存储从动态链接库中获取的API，它包含一个`Library`类型的引用。</span>
<span class="doccomment">//! 若`func_*`中的`&amp;&#39;a Library`指向了字段`library`，那`BundleService`便成为了一个自引用结构，内存布局是这样的：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +----------BundleService-------------+-------</span>
<span class="doccomment">//! | library | func_login | func_logout |  ...</span>
<span class="doccomment">//! +---------+------------+-------------+-------</span>
<span class="doccomment">//!     Λ           |             |</span>
<span class="doccomment">//!     +-----------+-------------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 那如果我们把`BundleService`移动到另一个内存位置，`func_*`不就指向被移动前的`library`了吗？像这样：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +---------+------------+-------------+-------+----------BundleService-------------+</span>
<span class="doccomment">//! |         |            |             |  ...  | library | func_login | func_logout |</span>
<span class="doccomment">//! +---------+------------+-------------+-------+---------+------------+-------------+</span>
<span class="doccomment">//!      Λ                                                       |             |</span>
<span class="doccomment">//!      +-------------------------------------------------------+-------------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Rust提供了非常强的安全保证，不会允许这种事发生。让我们构造一个`BundleService`的实例看看会发生什么：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! # pub struct BundleService&lt;&#39;a&gt; { </span>
<span class="doccomment">//! #     library: Library, </span>
<span class="doccomment">//! #     func_login: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//! #     func_logout: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! let mut bundle = BundleService {</span>
<span class="doccomment">//!     library: Library::open(&quot;service.dll&quot;).unwrap(), </span>
<span class="doccomment">//!     func_login: Function::dummy(), </span>
<span class="doccomment">//!     func_logout: Function::dummy(), </span>
<span class="doccomment">//! };</span>
<span class="doccomment">//! bundle.func_login = Function:: from_ref(&amp;bundle.library, &quot;login&quot;).unwrap();</span>
<span class="doccomment">//! bundle.func_logout = Function:: from_ref(&amp;bundle.library, &quot;logout&quot;).unwrap();</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 首先我们加载动态链接库获取`library`，并通过`dummy()`创建空白的`Function`s占位，构造一个没有自引用的`bundle`。然后再</span>
<span class="doccomment">//! 通过`bundle.library`获取真正的`func_*`函数，将它们赋值到`bundle`中。这样就构造成功了，我们获得了一个自引用的`bundle`。</span>
<span class="doccomment">//! 但如果我们尝试把它移动到另一个变量中，会得到一个编译错误。Rust允许我们构造这样一个自引用结构，但不能移动它。如果用户没有</span>
<span class="doccomment">//! 移动`bundle`的需求，这个设计看起来就够用了。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 然而，由于目前Rust没有完成Placement New这样的特性，我们无法为它编写一个`new`函数，因为从`new`函数中返回它也是Move操作。</span>
<span class="doccomment">//! 并且，我们无法在`bundle`上调用接收`&amp;mut self`的方法，因为`bundle`的一个字段已经被借用了，这给`BundleService`的实现带</span>
<span class="doccomment">//! 来了更多的限制。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Pinning</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 标准库提供了Pinning相关基础设施，给予我们将类型（的实例）钉死在内存中的能力。如果对Pinning有疑问，可以看一下[这个问答](&lt;#关于pinning的问答&gt;)。</span>
<span class="doccomment">//! 让我们先定义一个支持Pinned的`BundleService`类型：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::{ffi::c_void, marker::PhantomPinned};</span>
<span class="doccomment">//! pub struct BundleService {  </span>
<span class="doccomment">//!     library: Library, </span>
<span class="doccomment">//!     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//!     _marker: PhantomPinned, </span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 我们将引用换成了裸指针，摆脱了借用规则的约束；并通过`PhantomPinned`消除了`Unpin`的自动实现，使`BundleService`能够</span>
<span class="doccomment">//! 真正地被`Pin&lt;P&gt;`钉死在内存中。违反别名规则（Alias Rules）是未定义行为，现在没有了借用检查器的帮助，我们应当更加小心。</span>
<span class="doccomment">//! 接下来让我们为它构建一个Pinned的实例：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::{ffi::c_void, pin::Pin, marker::PhantomPinned};</span>
<span class="doccomment">//! # pub struct BundleService { </span>
<span class="doccomment">//! #     library: Library, </span>
<span class="doccomment">//! #     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//! #     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! #     _marker: PhantomPinned, </span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! let mut boxed = Box::pin(BundleService {</span>
<span class="doccomment">//!     library: Library::open(&quot;service.dll&quot;).unwrap(), </span>
<span class="doccomment">//!     func_login: Function::dummy(), </span>
<span class="doccomment">//!     func_logout: Function::dummy(), </span>
<span class="doccomment">//!     _marker: PhantomPinned, </span>
<span class="doccomment">//! });</span>
<span class="doccomment">//! unsafe {</span>
<span class="doccomment">//!     let pinned = Pin::get_unchecked_mut(Pin::as_mut(&amp;mut boxed));</span>
<span class="doccomment">//!     let raw_lib = &amp;pinned.library as *const Library;</span>
<span class="doccomment">//!     pinned.func_login = Function::from_raw(raw_lib, &quot;login&quot;).unwrap();</span>
<span class="doccomment">//!     pinned.func_logout = Function::from_raw(raw_lib, &quot;logout&quot;).unwrap();</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! let bundle: Pin&lt;Box&lt;BundleService&gt;&gt; = boxed;</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 我们先通过`dummy()`在堆上创建一个没有自引用的`bundle`，由于使用了`Box::pin`，此时在堆中的`BundleService`已经被钉死了。</span>
<span class="doccomment">//! 我们可以任意移动`bundle`这个变量，因为它只是一个指针，并且用户无法通过`bundle`移动真正的`BundleService`。然而，我们需要</span>
<span class="doccomment">//! 通过`library`获取真正的`func_*`，并用它们替换掉`dummy()`产生的空白函数。在这里我们通过`unsafe`实现这个目的，只要遵守</span>
<span class="doccomment">//! `get_unchecked_mut`的安全约定并且不产生未定义行为即可。最终我们构造了一个Pinned且自引用的`bundle`，内存布局是这样的：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +--------+-------</span>
<span class="doccomment">//! | bundle |  ...</span>
<span class="doccomment">//! +--------+-------</span>
<span class="doccomment">//!     |</span>
<span class="doccomment">//!     +------------+</span>
<span class="doccomment">//!                  V</span>
<span class="doccomment">//! +-----------BundleService------------+</span>
<span class="doccomment">//! | library | func_login | func_logout |</span>
<span class="doccomment">//! +---------+------------+-------------+</span>
<span class="doccomment">//!     Λ           |             |</span>
<span class="doccomment">//!     +-----------+-------------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 现在要实现`new`函数就很简单了，我们只需将这个构建好的`bundle`返回即可。这里使用`Box`只是因为方便，如果介意</span>
<span class="doccomment">//! 堆分配的开销，在用户侧构造`Pin&lt;&amp;mut BundleService&gt;`将`BundleService`钉死在调用栈中也是可行的，但这会更</span>
<span class="doccomment">//! 棘手一些。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 其实`Pin&lt;P&gt;`不太适合我们的场景，它是为Async Rust设计的，目的是将引用或指针从一段Unsafe代码（如：异步运行时的内部实现）</span>
<span class="doccomment">//! 通过一段未知的用户代码传递到另一段Unsafe代码（如：编译器为异步函数实现`Future`时生成的代码）时，保证「指向的值在内存中</span>
<span class="doccomment">//! 位置不会改变」的承诺不会被未知的用户代码破坏。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # 通过堆分配消除自引用</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 事实上，只要不把指针暴露给用户，仅需将被引用的数据放在堆中，就不会形成自引用了。想象这样一种内存布局：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +-------BundleService------+-------</span>
<span class="doccomment">//! | func_login | func_logout |  ...</span>
<span class="doccomment">//! +------------+-------------+-------</span>
<span class="doccomment">//!       /             |</span>
<span class="doccomment">//!      +--------------+</span>
<span class="doccomment">//!      V </span>
<span class="doccomment">//! +---------+</span>
<span class="doccomment">//! | library |</span>
<span class="doccomment">//! +---------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 我们可以选择使用裸指针实现它：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! pub struct BundleService {  </span>
<span class="doccomment">//!     library: *const Library, </span>
<span class="doccomment">//!     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 创建一个`Box&lt;Library&gt;`，通过`Box::into_raw`将其转换为裸指针，便可以在`func_*`中共享`Library`了。</span>
<span class="doccomment">//! 最后我们在`BundleService`的`drop`实现中通过`Box::from_raw`取回`Box`，它会在离开作用域后释放堆上</span>
<span class="doccomment">//! 的`Library`。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 也可以选择使用引用计数实现它：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::{ffi::c_void, rc::Rc};</span>
<span class="doccomment">//! pub struct BundleService {  </span>
<span class="doccomment">//!     library: Rc&lt;Library&gt;, </span>
<span class="doccomment">//!     func_login: Function&lt;Rc&lt;Library&gt;, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;Rc&lt;Library&gt;, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 使用裸指针需要用到`unsafe`，带来了更大的心智负担；使用引用计数更轻松一些，但带来了额外的性能惩罚。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # 成熟的解决方案</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 在C++中处理自引用结构会比较轻松，由于存在移动构造函数，类型的设计者可以在自引用结构被移动时更新类型中存在的指针。</span>
<span class="doccomment">//! 在Rust中处理自引用结构是比较麻烦的，但存在许多针对自引用结构的库，允许我们避开`unsafe`高效地实现自己的自引用结构。</span>
<span class="doccomment">//! 譬如rental就有一个相似的例子：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` ignore</span>
<span class="doccomment">//! rental! {</span>
<span class="doccomment">//!     pub mod rent_libloading {</span>
<span class="doccomment">//!         use libloading;</span>
<span class="doccomment">//!    </span>
<span class="doccomment">//!         #[rental(deref_suffix)] // This struct will deref to the Deref::Target of Symbol.</span>
<span class="doccomment">//!         pub struct RentSymbol&lt;S: &#39;static&gt; {</span>
<span class="doccomment">//!             lib: Box&lt;libloading::Library&gt;, // Library is boxed for StableDeref.</span>
<span class="doccomment">//!             sym: libloading::Symbol&lt;&#39;lib, S&gt;, // The &#39;lib lifetime borrows lib.</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! fn main() {</span>
<span class="doccomment">//!     let lib = libloading::Library::new(&quot;my_lib.so&quot;).unwrap(); // Open our dylib.</span>
<span class="doccomment">//!     if let Ok(rs) = rent_libloading::RentSymbol::try_new(</span>
<span class="doccomment">//!         Box::new(lib),</span>
<span class="doccomment">//!         |lib| unsafe { lib.get::&lt;extern &quot;C&quot; fn()&gt;(b&quot;my_symbol&quot;) }) // Loading symbols is unsafe.</span>
<span class="doccomment">//!     {</span>
<span class="doccomment">//!         (*rs)(); // Call our function</span>
<span class="doccomment">//!     };</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 简直方便极了有木有！</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## 结语</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 一方面，还是建议使用成熟的库，上文出现的Unsafe实现们作为参考就好。另一方面，可以考虑一下真的需要自引用结构吗？许多时候</span>
<span class="doccomment">//! 自引用结构也可以拆开封装，向用户暴露两个结构可能能够提供更多的灵活性呢。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## 关于Pinning的问答</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 1. Rust提供了默认的移动语义，不考虑Copy的情况下，类型（的实例）都是可以Move的。对此`Pin&lt;P&gt;`也不例外，为何它能阻止用户Move</span>
<span class="doccomment">//! 一个变量呢？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 关键就在于`P`，它不是我们想钉死在内存中的那个类型，而是对应类型的指针。Safe Rust中的可变性总是独占的，`Pin&lt;P&gt;`阻止用户从`P`中</span>
<span class="doccomment">//! 获取`&amp;mut T`，那么用户便无法修改`P`指向的`T`——失去了Move的能力。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 2. 那这样类型`T`的设计者怎么执行那些不移动`T`，但是需要`&amp;mut T`的操作呢？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 答案不是很优雅，`Pin&lt;P&gt;`提供了一些工具函数执行这样的操作，但更普遍的是通过`unsafe`获取`&amp;mut T`完成相关操作，健全性由类型的设计者保证。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 3. 用户等到`Pin&lt;P&gt;`离开作用域后，移动原变量，然后再构造一个`Pin&lt;P&gt;`，不就绕过Pinning的约束了吗？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 对于`Pin&lt;Box&lt;T&gt;&gt;`来说不存在这个问题，因为`Box&lt;T&gt;`是访问其指向的数据的唯一方式。对于普通的引用而言，这个顾虑是存在的，所以对变量直接</span>
<span class="doccomment">//! 构造一个`P&lt;&amp;mut T&gt;`需要`unsafe`，健全性由用户自行保证。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 4. 将变量钉死是通过别名规则（Alias Rules）实现的，修改钉死的变量是通过`unsafe`实现的，那`Pin&lt;P&gt;`存在的意义是什么呢？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! `Pin&lt;P&gt;`提供一种保证，将「值在内存中的位置不再改变」的承诺在两段`unsafe`代码间的用户代码中传递，基本上是针对Async Rust设计的。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! [回到Pinning一节](&lt;#pinning&gt;)</span>


<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">loading</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">error</span>;
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">dead_code</span>)]</span>
<span class="kw">mod</span> <span class="ident">factory</span>;


</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="self_ref_in_rust" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0-nightly (69a5d2481 2022-04-27)" ></div>
</body></html>