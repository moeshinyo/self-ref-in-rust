<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../self_ref_in_rust/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../self_ref_in_rust/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../self_ref_in_rust/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
</pre><pre class="rust"><code><span class="doccomment">//! # 引子</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 最近一位朋友遇到了这样一个问题：设计类型时，将具有引用关系的两个类型“打包”到同一个结构体中，产生了难以解决的编译错误。</span>
<span class="doccomment">//! 社区中也常常有同学问遇到类似的问题，在这篇文章中我们将从零开始，探究该如何设计这类自引用的类型，并逐步改进我们的设计。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 想象这样一个场景：在设计一个运行时调用动态链接库中的API的接口时，需要先加载动态链接库获得一个`Library`结构，</span>
<span class="doccomment">//! 再从`Library`中获取多个`Function`s（`Function`内部包含`Library`的引用），最后将`Library`与`Function`s放置到</span>
<span class="doccomment">//! 结构体`BundleService`中，于`BundleService`中将`Function`s封装为暴露给用户的方法。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 需求描述非常直观，简直就是把类型定义用文字写了出来，于是我们很快写出了这样一段定义：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! pub struct BundleService&lt;&#39;a&gt; {  </span>
<span class="doccomment">//!     library: Library, </span>
<span class="doccomment">//!     func_login: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 其中`library`是我们加载的动态链接库，`func_*`存储从动态链接库中获取的API，它包含一个`Library`类型的引用。</span>
<span class="doccomment">//! 若`func_*`中的`&amp;&#39;a Library`指向了字段`library`，那`BundleService`便成为了一个自引用结构，内存布局是这样的：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +----------BundleService-------------+-------</span>
<span class="doccomment">//! | library | func_login | func_logout |  ...</span>
<span class="doccomment">//! +---------+------------+-------------+-------</span>
<span class="doccomment">//!     Λ           |             |</span>
<span class="doccomment">//!     +-----------+-------------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 那如果我们把`BundleService`移动到另一个内存位置，`func_*`中的引用不就指向被移动前的`library`，变成</span>
<span class="doccomment">//! 悬垂引用了吗？像这样：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +---------+------------+-------------+-------+----------BundleService-------------+</span>
<span class="doccomment">//! |         |            |             |  ...  | library | func_login | func_logout |</span>
<span class="doccomment">//! +---------+------------+-------------+-------+---------+------------+-------------+</span>
<span class="doccomment">//!      Λ                                                       |             |</span>
<span class="doccomment">//!      +-------------------------------------------------------+-------------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Rust提供了非常强的安全保证，不会允许这种事发生。让我们先构造一个`BundleService`的实例看看：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! # pub struct BundleService&lt;&#39;a&gt; { </span>
<span class="doccomment">//! #     library: Library, </span>
<span class="doccomment">//! #     func_login: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//! #     func_logout: Function&lt;&amp;&#39;a Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! let mut bundle = BundleService {</span>
<span class="doccomment">//!     library: Library::open(&quot;service.dll&quot;).unwrap(), </span>
<span class="doccomment">//!     func_login: Function::dummy(), </span>
<span class="doccomment">//!     func_logout: Function::dummy(), </span>
<span class="doccomment">//! };</span>
<span class="doccomment">//! bundle.func_login = Function:: from_ref(&amp;bundle.library, &quot;login&quot;).unwrap();</span>
<span class="doccomment">//! bundle.func_logout = Function:: from_ref(&amp;bundle.library, &quot;logout&quot;).unwrap();</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - 首先加载动态链接库获取`library`，并通过`dummy()`创建空白的`Function`s占位，构造了一个没有自引用的`bundle`；</span>
<span class="doccomment">//! - 然后通过`bundle.library`获取了真正的`func_*`函数，将它们赋值到`bundle`中，这样`bundle`就变成了一个自引用结构。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 尽管构造成功了，可一旦我们尝试把它移动到另一个变量中，就会得到一个编译错误：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! error[E0505]: cannot move out of `bundle` because it is borrowed</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 这意味着：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - 这个自引用结构无法被移动、修改（不暴露字段的情况下）；</span>
<span class="doccomment">//! - 这个自引用结构不能有接收`&amp;mut self`的方法。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 也就是说Rust允许我们构造这样一个自引用结构，但不能移动或直接修改它。</span>
<span class="doccomment">//! 这样的限制过于严格了，我们需要更加灵活的方案。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Pinning</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 标准库提供了Pinning相关基础设施，给予我们将类型（的实例）“钉”在内存中的能力。</span>
<span class="doccomment">//! 让我们试试基于Pinning的方案，也许灵活性会更高呢。</span>
<span class="doccomment">//! 如果对Pinning有疑问，可以看一下这个[关于Pinning的问答](&lt;#关于pinning的问答&gt;)。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 让我们先定义一个支持Pinned的`BundleService`类型：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::{ffi::c_void, marker::PhantomPinned};</span>
<span class="doccomment">//! pub struct BundleService {  </span>
<span class="doccomment">//!     library: Library, </span>
<span class="doccomment">//!     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//!     _marker: PhantomPinned, </span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - 首先将引用换成了裸指针，摆脱了借用规则的约束；</span>
<span class="doccomment">//! - 并通过`PhantomPinned`消除了`Unpin`的自动实现，使`BundleService`能够真正地被`Pin&lt;P&gt;`“钉”在内存中。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 接下来让我们尝试为它构建一个Pinned的实例，实现`new`方法：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::{ffi::c_void, pin::Pin, marker::PhantomPinned};</span>
<span class="doccomment">//! # pub struct BundleService { </span>
<span class="doccomment">//! #     library: Library, </span>
<span class="doccomment">//! #     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//! #     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! #     _marker: PhantomPinned, </span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! impl BundleService {</span>
<span class="doccomment">//!     fn new() -&gt; Pin&lt;Box&lt;Self&gt;&gt; {</span>
<span class="doccomment">//!         let mut bundle = Box::pin(BundleService {</span>
<span class="doccomment">//!             library: Library::open(&quot;service.dll&quot;).unwrap(), </span>
<span class="doccomment">//!             func_login: Function::dummy(), </span>
<span class="doccomment">//!             func_logout: Function::dummy(), </span>
<span class="doccomment">//!             _marker: PhantomPinned, </span>
<span class="doccomment">//!         });</span>
<span class="doccomment">//!         unsafe {</span>
<span class="doccomment">//!             let pinned = Pin::get_unchecked_mut(Pin::as_mut(&amp;mut bundle));</span>
<span class="doccomment">//!             let raw_lib = &amp;pinned.library as *const Library;</span>
<span class="doccomment">//!             pinned.func_login = Function::from_raw(raw_lib, &quot;login&quot;).unwrap();</span>
<span class="doccomment">//!             pinned.func_logout = Function::from_raw(raw_lib, &quot;logout&quot;).unwrap();</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!         bundle</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - 先通过`Box::pin`在堆上创建了一个没有自引用的`bundle`。此时堆上的`BundleService`已经被“钉”住了。用户在Safe Rust中无法</span>
<span class="doccomment">//!   通过`bundle`获取一个`&amp;mut BundleService`，也就无法移动堆上的`BundleService`。</span>
<span class="doccomment">//! - 然后我们通过`unsafe`获取`&amp;mut BundleService`，从`library`中获取真正的`func_*`，并用它们替换掉`dummy()`产生的空白函数</span>
<span class="doccomment">//!   完成对`bundle`的初始化。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 只要遵守`get_unchecked_mut`的安全约定并且不产生未定义行为，我们在这里使用`unsafe`是安全的。</span>
<span class="doccomment">//! 最终我们构造了一个`bundle`，它能够被自由移动，也就能够从`new`方法中返回。</span>
<span class="doccomment">//! 它指向的`BundleService`被“钉”在了内存中，也就不用担心引用失效的问题了。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 内存布局是这样的：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +--------+-------</span>
<span class="doccomment">//! | bundle |  ...</span>
<span class="doccomment">//! +--------+-------</span>
<span class="doccomment">//!     |</span>
<span class="doccomment">//!     +------------+</span>
<span class="doccomment">//!                  V</span>
<span class="doccomment">//! +-----------BundleService------------+</span>
<span class="doccomment">//! | library | func_login | func_logout |</span>
<span class="doccomment">//! +---------+------------+-------------+</span>
<span class="doccomment">//!     Λ           |             |</span>
<span class="doccomment">//!     +-----------+-------------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 这里使用`Box`只是因为方便，如果介意堆分配的开销，在用户侧构造`Pin&lt;&amp;mut BundleService&gt;`将`BundleService`</span>
<span class="doccomment">//! “钉”在调用栈中也是可行的，但这会更棘手一些。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ---</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 其实`Pin&lt;P&gt;`不太适合我们的场景，它是为Async Rust设计的，目的是将引用或指针从一段Unsafe代码（如：异步运行时的内部实现）</span>
<span class="doccomment">//! 通过一段未知的用户代码传递到另一段Unsafe代码（如：编译器为异步函数实现`Future`时生成的代码）中时，保证「指向的值在内存中</span>
<span class="doccomment">//! 位置不会改变」的承诺不会被未知的用户代码破坏。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # 通过堆分配消除自引用</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 基于Pinning的方案的确实现了我们的目标，但由于应用场景的差异，它做了许多没有必要的事。</span>
<span class="doccomment">//! 事实上，只要不把指针暴露给用户，仅需将被引用的数据放在堆中，就不会形成自引用了。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 想象这样一种内存布局：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` text</span>
<span class="doccomment">//! +-------BundleService------+-------</span>
<span class="doccomment">//! | func_login | func_logout |  ...</span>
<span class="doccomment">//! +------------+-------------+-------</span>
<span class="doccomment">//!       /             |</span>
<span class="doccomment">//!      +--------------+</span>
<span class="doccomment">//!      V </span>
<span class="doccomment">//! +---------+</span>
<span class="doccomment">//! | library |</span>
<span class="doccomment">//! +---------+</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 类似于Pinning的方案，在这种设计中，移动`BundleService`并不会造成引用失效。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 我们可以选择通过`Box::into_raw`实现这个方案：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! pub struct BundleService {  </span>
<span class="doccomment">//!     library: *const Library, </span>
<span class="doccomment">//!     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! impl BundleService {</span>
<span class="doccomment">//!     fn new() -&gt; Self {</span>
<span class="doccomment">//!         let library = Box::into_raw(Box::new(Library::open(&quot;service.dll&quot;).unwrap()))</span>
<span class="doccomment">//!             as *const _;</span>
<span class="doccomment">//!         Self {</span>
<span class="doccomment">//!             library: library, </span>
<span class="doccomment">//!             func_login: unsafe { Function::from_raw(library, &quot;login&quot;).unwrap() },</span>
<span class="doccomment">//!             func_logout: unsafe { Function::from_raw(library, &quot;logout&quot;).unwrap() },</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - 创建一个`Box&lt;Library&gt;`，通过`Box::into_raw`将其转换为裸指针，便可以在`func_*`中共享`Library`了。 </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 当然，也不要忘了回收资源，否则会造成内存泄露：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::ffi::c_void;</span>
<span class="doccomment">//! # pub struct BundleService {  </span>
<span class="doccomment">//! #     library: *const Library, </span>
<span class="doccomment">//! #     func_login: Function&lt;*const Library, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//! #     func_logout: Function&lt;*const Library, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! # }</span>
<span class="doccomment">//! impl Drop for BundleService {</span>
<span class="doccomment">//!     fn drop(&amp;mut self) {</span>
<span class="doccomment">//!         self.func_login = Function::dummy();</span>
<span class="doccomment">//!         self.func_logout = Function::dummy();        </span>
<span class="doccomment">//!         let _library = unsafe { Box::from_raw(self.library as *mut Library) };</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - 在`BundleService`的`drop`实现中通过`Box::from_raw`取回`Box&lt;Library&gt;`，它会在离开作用域后释放堆上的`Library`；</span>
<span class="doccomment">//! - 在`_library`被释放前，先释放`func_*`，保证被引用的`Library`的生命周期严格长于引用它的`Function`s。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ---</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 也可以选择使用引用计数实现这个方案：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! # use self_ref_in_rust::{loading::{Library, Function}, error::Result};</span>
<span class="doccomment">//! # use std::{ffi::c_void, rc::Rc};</span>
<span class="doccomment">//! pub struct BundleService {  </span>
<span class="doccomment">//!     library: Rc&lt;Library&gt;, </span>
<span class="doccomment">//!     func_login: Function&lt;Rc&lt;Library&gt;, extern &quot;C&quot; fn(*const c_void) -&gt; i32&gt;,</span>
<span class="doccomment">//!     func_logout: Function&lt;Rc&lt;Library&gt;, extern &quot;C&quot; fn() -&gt; i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! impl BundleService {</span>
<span class="doccomment">//!     fn new() -&gt; Self {</span>
<span class="doccomment">//!         let library = Rc::new(Library::open(&quot;service.dll&quot;).unwrap());</span>
<span class="doccomment">//!         Self {</span>
<span class="doccomment">//!             library: library.clone(), </span>
<span class="doccomment">//!             func_login: Function::from_ref(library.clone(), &quot;login&quot;).unwrap(),</span>
<span class="doccomment">//!             func_logout: Function::from_ref(library.clone(), &quot;logout&quot;).unwrap(),</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 使用引用计数就不再需要手动释放资源了，也避免了使用`unsafe`，只是会带来一定的运行时开销。不过比起操纵裸指针带来的风险与</span>
<span class="doccomment">//! 心智负担，引用计数微不足道的开销通常都是能够接受的。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # 成熟的解决方案</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 在C++中处理自引用结构会比较轻松，由于存在移动构造函数，类型的设计者可以在自引用结构被移动时更新类型中存在的指针。</span>
<span class="doccomment">//! 在Rust中处理自引用结构是比较麻烦的，但也存在许多针对自引用结构的库，允许我们避开`unsafe`方便地实现自己的自引用结构。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 譬如[rental](&lt;https://docs.rs/rental/0.5.6/rental/index.html#example&gt;)就有一个相似的例子：</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ``` ignore</span>
<span class="doccomment">//! rental! {</span>
<span class="doccomment">//!     pub mod rent_libloading {</span>
<span class="doccomment">//!         use libloading;</span>
<span class="doccomment">//!    </span>
<span class="doccomment">//!         #[rental(deref_suffix)] // This struct will deref to the Deref::Target of Symbol.</span>
<span class="doccomment">//!         pub struct RentSymbol&lt;S: &#39;static&gt; {</span>
<span class="doccomment">//!             lib: Box&lt;libloading::Library&gt;, // Library is boxed for StableDeref.</span>
<span class="doccomment">//!             sym: libloading::Symbol&lt;&#39;lib, S&gt;, // The &#39;lib lifetime borrows lib.</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! fn main() {</span>
<span class="doccomment">//!     let lib = libloading::Library::new(&quot;my_lib.so&quot;).unwrap(); // Open our dylib.</span>
<span class="doccomment">//!     if let Ok(rs) = rent_libloading::RentSymbol::try_new(</span>
<span class="doccomment">//!         Box::new(lib),</span>
<span class="doccomment">//!         |lib| unsafe { lib.get::&lt;extern &quot;C&quot; fn()&gt;(b&quot;my_symbol&quot;) }) // Loading symbols is unsafe.</span>
<span class="doccomment">//!     {</span>
<span class="doccomment">//!         (*rs)(); // Call our function</span>
<span class="doccomment">//!     };</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 简直方便极了有木有！</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # 结语</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 一方面，还是建议使用成熟的库，上文出现的Unsafe实现们作为参考就好。另一方面，可以考虑一下真的需要自引用结构吗？许多时候</span>
<span class="doccomment">//! 自引用结构也可以拆开封装，向用户暴露两个结构可能能够提供更多的灵活性呢。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ---</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## 关于Pinning的问答</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 1. Rust提供了默认的移动语义，不考虑Copy的情况下，类型（的实例）都是可以Move的。对此`Pin&lt;P&gt;`也不例外，为何它能阻止用户Move</span>
<span class="doccomment">//! 一个变量呢？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! &gt; 关键在于类型`P`，它并不是我们想“钉”在内存中的那个类型，而是对应类型的指针。Safe Rust中的可变性总是独占的，`Pin&lt;P&gt;`阻止用户从`P`中</span>
<span class="doccomment">//! 获取`&amp;mut T`，那么用户便无法修改`P`指向的`T`——失去了Move的能力。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 2. 那这样类型`T`的设计者怎么执行那些不移动`T`，但是需要`&amp;mut T`的修改操作呢？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! &gt; 答案不是很优雅，`Pin&lt;P&gt;`提供了一些工具函数执行这样的操作，但更普遍的是通过`unsafe`获取`&amp;mut T`完成相关操作，健全性由类型的设计者保证。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 3. 用户等到`Pin&lt;P&gt;`离开作用域后，移动原变量，然后再构造一个`Pin&lt;P&gt;`，不就绕过Pinning的约束了吗？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! &gt; 对于`Pin&lt;Box&lt;T&gt;&gt;`来说不存在这个问题，因为`Box&lt;T&gt;`是访问其指向的数据的唯一方式。对于普通的引用而言，这个顾虑是存在的，所以对变量直接</span>
<span class="doccomment">//! 构造一个`P&lt;&amp;mut T&gt;`需要`unsafe`，健全性由用户自行保证。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! 4. 将变量“钉”在内存中是通过借用规则实现的，修改“钉”在内存中的变量是通过`unsafe`实现的，那`Pin&lt;P&gt;`存在的意义是什么呢？</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! &gt; `Pin&lt;P&gt;`提供一种保证，将「值在内存中的位置不再改变」的承诺在两段`unsafe`代码间的用户代码中传递，基本上是针对Async Rust设计的。</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! [回到Pinning一节](&lt;#pinning&gt;)</span>


<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">loading</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">error</span>;
<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">dead_code</span>)]</span>
<span class="kw">mod</span> <span class="ident">factory</span>;


</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="self_ref_in_rust" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0-nightly (69a5d2481 2022-04-27)" ></div>
</body></html>